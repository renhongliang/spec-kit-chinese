---
description: 使用计划模板执行实施规划工作流以生成设计工件。
handoffs: 
  - label: 创建任务
    agent: speckit.tasks
    prompt: 将计划分解为任务
    send: true
  - label: 创建检查清单
    agent: speckit.checklist
    prompt: 为以下领域创建检查清单...
scripts:
  sh: scripts/bash/setup-plan.sh --json
  ps: scripts/powershell/setup-plan.ps1 -Json
agent_scripts:
  sh: scripts/bash/update-agent-context.sh __AGENT__
  ps: scripts/powershell/update-agent-context.ps1 -AgentType __AGENT__
---

## 用户输入

```text
$ARGUMENTS
```

如果用户输入不为空，你**必须**在继续之前考虑用户输入。

## 概述

1. **设置**：从仓库根目录运行 `{SCRIPT}` 并解析 JSON 以获取 FEATURE_SPEC、IMPL_PLAN、SPECS_DIR、BRANCH。对于参数中的单引号，如 "I'm Groot"，使用转义语法：例如 'I'\''m Groot'（如果可能，使用双引号："I'm Groot"）。

2. **加载上下文**：
   - 读取 FEATURE_SPEC 和 `/memory/constitution.md`
   - **读取产品文档**：检查并加载 `/memory/product.md`（如果存在）
     - 从产品文档中提取：
       - 产品定位和愿景（用于技术决策的上下文）
       - 利益相关方信息（用于理解需求来源）
       - 当前功能的关联产品特性信息（特性ID、业务价值、优先级）
   - **读取全局架构文档**（增量开发支持）：
     - **组件架构文档**：检查并加载 `/memory/components-global.md`（如果存在）
       - 从组件文档中提取：
         - 现有组件列表、职责和边界
         - 组件类型和技术栈
         - 组件间的依赖关系
         - 组件的数据所有权
     - **数据模型文档**：检查并加载 `/memory/data-model-global.md`（如果存在）
       - 从数据模型文档中提取：
         - 现有数据模型实体
         - 实体与组件的关联
         - 跨组件实体关系
     - **API 架构文档**：检查并加载 `/memory/api-global.md`（如果存在）
       - 从 API 文档中提取：
         - 现有 API 端点
         - 端点与组件的关联
         - 组件间 API 调用关系
   - 加载 IMPL_PLAN 模板（已复制）

3. **执行计划工作流**：遵循 IMPL_PLAN 模板中的结构：
   - **产品上下文集成**：
     - 在技术上下文中引用产品定位和愿景
     - 考虑利益相关方需求对技术选择的影响
     - 确保技术决策与产品版本兼容性要求一致
     - 在计划中明确标注关联的产品特性ID和业务价值
   
   - **全局架构上下文集成**（增量开发支持）：
     - 如果全局文档存在，在技术上下文中引用：
       - **组件架构**：现有组件的职责、边界和技术栈（从 `components-global.md`）
       - **数据模型**：现有数据模型模式和实体关系（从 `data-model-global.md`）
       - **API 架构**：现有 API 设计模式和版本策略（从 `api-global.md`）
       - **集成模式**：组件间的依赖关系和通信方式（从 `components-global.md`）
     - 确保新功能与现有架构保持一致：
       - 复用现有组件（如适用）
       - 遵循现有的技术栈选择
       - 遵循现有的 API 设计模式
       - 考虑与现有组件的集成需求
     - 如果创建新组件，说明与现有架构的集成方式
   
   - 填写技术上下文（将未知项标记为"需要澄清"）
   - 从宪法填写宪法检查章节
   - 评估门控（如果违规未得到合理解释则报错）
   - 阶段0：生成 research.md（解决所有需要澄清的问题）
   - 阶段1：生成 data-model.md、contracts/、quickstart.md 并更新全局架构文档
   - 阶段1：通过运行代理脚本更新代理上下文
   - 设计后重新评估宪法检查

4. **停止并报告**：命令在阶段2规划后结束。报告：
   - 分支和 IMPL_PLAN 路径
   - 功能级别的生成工件（data-model.md、contracts/、quickstart.md）
   - 全局架构文档更新情况（组件ID、新增实体、新增端点）
   - 组件分配决策和依赖关系
   - 提醒：后续功能开发应参考全局架构文档，确保一致性

## 阶段

### 阶段0：概述与研究

1. **从上面的技术上下文中提取未知项**：
   - 对于每个需要澄清 → 研究任务
   - 对于每个依赖项 → 最佳实践任务
   - 对于每个集成 → 模式任务

2. **生成并分派研究代理**：

   ```text
   对于技术上下文中的每个未知项：
     任务："研究 {unknown} 用于 {feature context}"
   对于每个技术选择：
     任务："查找 {tech} 在 {domain} 中的最佳实践"
   ```

3. **在 `research.md` 中整合发现**，使用格式：
   - 决策：[选择了什么]
   - 理由：[为什么选择]
   - 考虑的替代方案：[还评估了什么]

**输出**：research.md，所有需要澄清的问题已解决

### 阶段1：设计与合约

**先决条件**：`research.md` 完成

1. **组件识别与分配**（增量开发支持）：
   - **分析功能规范**，确定功能应归属的组件：
     - 如果全局文档存在，检查现有组件是否适合此功能
     - 如果适合现有组件，使用现有组件ID
     - 如果不适合，创建新组件（生成新的组件ID：C-XXX）
   
   - **组件分配原则**（复杂度分割）：
     - **职责分离**：每个组件应有明确的单一职责
     - **数据所有权**：实体应归属于拥有其数据的组件
     - **业务边界**：按业务领域或子域划分组件
     - **技术边界**：考虑技术栈差异（如需要不同的运行时环境）
     - **规模控制**：避免组件过大，保持可管理性
     - **依赖最小化**：尽量减少组件间的依赖关系
   
   - **组件类型识别**：
     - **微服务**：独立部署、独立数据库、通过 API 通信
     - **模块**：单体应用内的逻辑模块，共享数据库
     - **服务**：可复用的业务服务，可能被多个组件调用
   
   - **组件决策记录**：
     - 在计划中记录组件分配决策
     - 说明为什么选择此组件或创建新组件
     - 记录组件间的依赖关系
     - 记录数据流和 API 调用关系

2. **从功能规范中提取实体** → `data-model.md`（功能级别）：
   - 实体名称、字段、关系
   - 来自需求的验证规则
   - 如果适用，状态转换
   - **标记组件归属**：为每个实体标记所属组件ID

3. **更新全局数据模型** → `/memory/data-model-global.md`（增量更新）：
   - **检查全局文件是否存在**：
     - 如果不存在：从模板创建 `/memory/data-model-global.md`
       - 模板位置：`.specify/templates/data-model-global-template.md` 或 `templates/data-model-global-template.md`
     - 如果存在：读取现有内容
   
   - **更新组件信息**：
     - 如果使用现有组件：
       - 在组件的数据模型表中添加新实体
       - 在实体详情部分添加新实体条目
       - 记录实体来源 Spec ID（BRANCH_NAME）
     - 如果创建新组件：
       - 在组件索引表中添加新组件
       - 创建新组件的完整详情部分
       - 包含组件职责、技术栈、数据模型
   
   - **建立关联关系**：
     - 记录实体与 Spec ID 的关联
     - 识别并记录跨组件实体关系
     - 更新跨组件实体关系表
   
   - **验证一致性**：
     - 确保实体定义与功能级别的 data-model.md 一致
     - 检查跨组件关系的合理性
     - 验证数据一致性规则

4. **从功能需求生成API合约** → `/contracts/`（功能级别）：
   - 对于每个用户操作 → 端点
   - 使用标准 REST/GraphQL 模式
   - 将 OpenAPI/GraphQL 模式输出到 `/contracts/`
   - **标记组件归属**：为每个端点标记所属组件ID

5. **更新全局 API 架构** → `/memory/api-global.md`（增量更新）：
   - **检查全局文件是否存在**：
     - 如果不存在：从模板创建 `/memory/api-global.md`
       - 模板位置：`.specify/templates/api-global-template.md` 或 `templates/api-global-template.md`
     - 如果存在：读取现有内容
   
   - **更新组件 API**：
     - 如果使用现有组件：
       - 在组件的 API 端点表中添加新端点
       - 在端点详情部分添加新端点条目
       - 记录端点来源 Spec ID（BRANCH_NAME）
       - 关联到相应的用户故事
     - 如果创建新组件：
       - 在组件索引表中添加新组件
       - 创建新组件的完整详情部分
       - 包含组件职责、技术栈、API 端点列表
   
   - **建立关联关系**：
     - 记录端点与 Spec ID 的关联
     - 识别并记录组件间 API 调用关系
     - 更新跨组件 API 集成表
     - 记录事件发布/订阅关系（如适用）
   
   - **验证一致性**：
     - 确保端点定义与功能级别的 contracts/ 一致
     - 检查跨组件调用的合理性
     - 验证 API 版本兼容性

6. **代理上下文更新**：
   - 运行 `{AGENT_SCRIPT}`
   - 这些脚本检测正在使用的AI代理
   - 更新相应的代理特定上下文文件
   - 仅添加来自当前计划的新技术
   - 保留标记之间的手动添加

**输出**：
- 功能级别：data-model.md、/contracts/*、quickstart.md
- 全局级别：/memory/data-model-global.md（更新）、/memory/api-global.md（更新）
- 代理特定文件

## 关键规则

- 使用绝对路径
- 门控失败或未解决的澄清时出错
